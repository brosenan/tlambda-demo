(ns tlambda)

;; Types

(all [t]
     [:type_def t] =>
     (fact (type-alias t (atomic-type t))))

(all [a t]
     (type-alias a t ! "Invalid type" a))

(all [a t]
     [:type_alias_def a t] =>
     (assert (type t))
     (fact (type-alias a t)))

(all [t]
     (type t ! "Invalid type" t))

(all [a]
     (type [:type_alias a]) <-
     (exist [t]
            (type-alias a t)))

(all [t1 t2]
     (type [:func_type t1 t2]) <-
     (type t1)
     (type t2))

;; Primitives

(all [p t]
     [:primitive_def p t] =>
     (assert (type t)))

;; Typed Definition

(all [v t x]
     [:typed_definition v t x] =>
     (assert (type t)))


;;;;;;;;;;;;;;;;;;;;

(all [v x]
     [:definition v x] =>
     (assert (lambda-expr x))
     (fact (lambda-expr v)))

(all [x]
     (lambda-expr x ! x "is not a valid lambda expression"))

(all [x]
     (lambda-expr [:expr x]) <-
     (lambda-expr x))

(all [ps x]
     (lambda-expr [:lambda_abst ps x]) <-
     (given ps
            (lambda-expr x)))

(all [p ps]
     [:params p & ps] =>
     (fact (lambda-expr p))
     [:params & ps])

(all [f x]
     (lambda-expr [:func_application f x]) <-
     (lambda-expr f)
     (lambda-expr x))

(all [v x]
     [:public_def [:definition v x]] =>
     [:definition v x]
     (export [v' v]
             (fact (lambda-expr v'))))

(all [d]
     [:import [:dep d]] =>
     (import d))